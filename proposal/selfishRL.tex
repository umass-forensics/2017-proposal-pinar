%!TEX root = umthsmpl.tex
\chapter{RL Applied to Bitcoin}\label{selfishRL}
\section{Background}
\subsection{Selfish Mining and Double-Spend Attacks}
\subsection{Related Work}
The standard Bitcoin protocol requires miners to broadcast a block they mined immediately. However, in the case of selfish mining, a miner purposefully withholds his blocks. The motivation is to bifurcate the chain and waste the computational resources of the honest miners should the network decide to build on the attacker's chain. An attacker can not profit economically since the number of blocks that can be created by a miner depends on the fraction of the mining power he has. However, selfish mining discards the honest miners' blocks, by releasing an alternative chain that takes over the current longest chain. If a selfish mining attack is successful, the selfish miners own a higher fraction of the blocks on the main chain because some portion of the blocks created by the honest network go to waste.

Eyal et al.~\cite{eyal:2014} modeled selfish mining using a Markov chain. Then Sapirshtein et al.~\cite{sapirshtein:2015} created a more complex model using a Markov decision process (MDP) for selfish mining and computed the $\epsilon$-optimal policy that increases a selfish miner's revenue. Recently, Gervais et al.~\cite{Gervais:2016} incorporated additional parameters such as network conditions and Bitcoin settings into the MDP to study the affects of such parameters on the attacker's policy. %that affect  attacker strategy, including mining power, block depth, connectivity, and the impact of eclipse attacks.
\section{Problem Statement}
In this project, we study a form of adversarial behavior in cryptocurrencies. Known as selfish mining, this behavior involves the deliberate withholding of transaction information. We study whether an attacker who wants to perform selfish mining could use a reinforcement learning method to search for the optimal strategy. Furthermore, we compare the optimal policy found by RL algorithms to those cited in previous work.

\para{Parametrization of $\beta$.}
Let $X = X_1, \dots, X_{n}$, where $X \sim$ Exp$(\beta)$, where $\beta = 1/\lambda$. The MLE estimator for $\beta$ is
\begin{align}
\hat{\beta} = \frac{\sum_{i=1}^{n} X_i}{n}
\end{align}
The expected value of the estimator is 
\begin{align}
\EX[\hat{\beta} | \beta] &= \frac{1}{n}\EX \Bigg[\sum_{i=1}^{n} X_i \Bigg] \\
&= \frac{1}{n}n\beta \\
&= \beta
\end{align}
This estimator \textit{not} biased. The bias is
\begin{align}
\text{bias}(\hat{\beta}) &= \EX[\hat{\beta} | \beta] - \beta \\
&= \beta - \beta \\
&= 0
\end{align}
The variance of the estimator is
\begin{align}
\text{Var}(\hat{\beta}) &= \text{Var}\Bigg(\frac{\sum_{i=1}^{n} X_i}{n}\Bigg) \\
&= \frac{1}{n^2} \text{Var}\Bigg(\sum_{i=1}^{n} X_i\Bigg) \\
&= \frac{1}{n^2} n\beta^2\\
&= \frac{1}{n}\beta^2
\end{align}
Ideally, in Bitcoin $\beta = 1/10$ mins and in Ethereum $\beta = 1/15$ secs. Note that the variance increases with more data (more inter-arrival times).

\para{Understanding the Relationship Between Hash Rate and $\beta$.}
Given target $T_i$, the expected number of hashes, $h$, needed to meet the target for a block is
\begin{align}
\EX[h] = \frac{2^{256}-1}{T_i}
\end{align}
However, $\EX[h]$ describes the \textit{total} number of expected hashes needed to find a block. We have observations regarding the \textit{time} it takes to generate a block. Let $r$ be the hash rate of the network in minutes (or the number of hashes per time unit), and $X = X_1, \dots, X_{n}$, where $X \sim$ Exp$(\beta)$, where $\beta = 1/\lambda$. Note that $\lambda r$ is the expected number of hashes each time a block is created.  %We do not know the real value of $\beta$ but can use the estimator in eq. 1.
\begin{align}
\EX[h] = r \lambda &= r \frac{1}{\beta}  \\
r &= \EX[h] \beta
\end{align}

\para{Expected Value of Hash Rate.}
\begin{align}
\EX[r|T_i,X_1,...,X_n] &= \EX\bigg[\frac{(2^{256}-1)\hat{\beta}}{T_i}\bigg] \\
&= \frac{(2^{256}-1)}{T_i}\EX[\hat{\beta}] \\
&= \frac{(2^{256}-1)\beta}{T_i}
\end{align}

\para{Variance of Hash Rate.}
\begin{align}
\text{Var}(r|T_i,X_1,...,X_n) &= \text{Var}\bigg(\frac{(2^{256}-1)\hat{\beta}}{T_i}\bigg) \\
&= \frac{(2^{256}-1)^2}{T_i^2} \text{Var}(\hat{\beta}) \\
&= \frac{(2^{256}-1)^2\beta^2}{T_i^2n}
\end{align}

\para{Bias of Hash Rate.}
\begin{align}
\text{bias}(r|T_i,X_1,...,X_n) &= \EX[r|T_i,X_1,...,X_n] - r \\
&= \frac{(2^{256}-1)\beta}{T_i} - \frac{(2^{256}-1)\beta}{T_i} \\
&= 0
\end{align}

The variance for estimating the miner hash rate is huge! You'd require more blocks than those that are in the blockchain to reduce variance! Therefore, let's use RL. 

\para{Example.}
The current Bitcoin difficulty, $D_i$, is $1,590,896,927,258 \approx 2^{40}$. This means the current target, $T_i$, is
\begin{align}
T_i &= \frac{2^{224}}{D_i} = \frac{2^{224}}{2^{40}} \\
&\approx 2^{184}
\end{align}
Then approximately the variance associated with the hash rate is 
\begin{align}
\text{Var}(r|T_i,X_1,...,X_n) &= \frac{(2^{256}-1)^2\beta^2}{T_i^2n} \\
&\approx  \frac{(2^{256})^2\beta^2}{T_i^2n} \\
&\approx  \frac{(2^{256})^2\beta^2}{(2^{184})^2n} \\
&\approx  \frac{2^{512}\beta^2}{2^{368}n} \\
&\approx  2^{144}\frac{\beta^2}{n}
\end{align}
A huge number no matter what $\beta$ or $n$ is!

\section{Preliminary Work}
\subsection{Formulating the Problem as an MDP}
\para{States.} Using Sapirshtein et al.~\cite{sapirshtein:2015}'s model as a basis, we construct the following MDP that is a 6-tuple $\{S, A, P, R, \gamma, d_0\}$, where $S = \{(x, y, z)\}$ such that $x, y, z \in \mathbb{N}$. The state consists of a 3-tuple where $x$ denotes the number of blocks on the attacker's hidden chain, $y$ denotes the number of blocks created by the honest miners on the main chain, and $z$ denotes the number of blocks that the attacker released on the main chain. Note that this representation assumes that all blocks build on the same parent block. 

\para{Actions.} $A = \{\texttt{adopt}, \texttt{mine}, \texttt{override}, \texttt{match}\}$. \texttt{adopt} refers to the adoption of the main chain, thereby discarding all blocks created by the attacker. The action \texttt{mine} denotes that the attacker continues to mine, waiting to see who the next block will be discovered by. \texttt{override} refers to an attacker's releasing one more block than the honest miners' blocks on the main chain. This action can be viewed as honest or selfish depending on the current state. If the honest miners have no blocks on the main chain, an addition of a block to the main chain means that the attacker is honest. However, if the honest miners already have blocks on the main chain and the attacker releases an alternative chain that is 1 block longer than that created by the honest miners, then the attacker overwrites the main chain, wasting the victim's computational resources. The \texttt{match} action means that the attacker releases as many blocks as there are on the main chain, causing a bifurcation.

\para{Initial state distribution.} $d_0 = \{(0, 0, 0)\}$, where $P(S_0 = (0, 0, 0)) = 1$. In other words, the start state assumes that no blocks have been mined yet. When the attacker chooses the action  \texttt{adopt}, the agent goes back to the start state because a new parent block is chosen to build on top of.

\para{Transition Function.} We consider 3 of parameters of interest included in Gervais et al.~\cite{Gervais:2016}'s model. At each time step, a new block is created by the network: with probability $q$, where $q$ is the mining power of the attacker, the attacker is the winner of a new block. The honest network discovers a block with probability $1-q$. Not all actions are available in every state. The attacker can always choose the \texttt{mine} action. The \texttt{adopt} action is only available when there are blocks on the main chain created by the honest network. Additionally, \texttt{override} and \texttt{match} are only available when the attackers have enough blocks. At cutoff, $c=30$, we force the attacker to choose the \texttt{adopt} action in order to have episodic trials. If the number of blocks created by the honest miners exceeds those of the attacker by $c$, we force the attacker to end the episode. Our third parameter, $a$, represents network connectivity. If there is a fork of same length on the main chain, fraction $a$ of the honest miners build on the attacker's alternative chain. We set $a=1$ to give advantage to the attacker, and to see if RL methods can learn to take advantage of the \texttt{match} action. If the attacker matches the main chain with a fork of the same length, all honest miners build on the attacker's chain. 

\section{Proposed Work}

