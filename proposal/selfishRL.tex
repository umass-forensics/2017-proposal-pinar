%!TEX root = umthsmpl.tex
\chapter{RL Applied to Bitcoin}\label{selfishRL}

\section{Background}

\subsection{Selfish Mining and Double-Spend Attacks}
Blockchain systems~\cite{Nakamoto:2009} provide probabilistic consensus~\cite{Vukolic:2015} among a set of peers on the order and validity of a set of blocks, each containing transactions. The blockchain encodes the consensus as the {\em main chain} among all possible forks. 
As the {\em depth} of a block on the main chain increases, there is an exponentially decreasing probability that network consensus will switch the main chain to a fork that does not include the block~\cite{Nakamoto:2009,Feller:1968}. This result assumes that the attacker never stops mining on the alternative fork, regardless of cost.  A more realistic model assumes that attackers have finite  time and resources, and would not expend resources on an attack that isn't expected to be profitable. 
%Furthermore, only in theory do blockchains accept new forks of any length from  attackers;  in practice, the largest attacks on blockchains have been manually set aside~\cite{Castillo:2016,Castillo:2016a,Gervais:2014}. 

Recently, Gervais et al.~\cite{Gervais:2016} evaluated the security of blockchains in terms of an attacker's economic profitably and assuming finite resources. They modeled a double-spending attacker's strategy  as Markov Decision Process. MDPs are defined by a finite set of discrete states, a set of actions, a transition function, and a reward function. They defined each  state in the MDP as a tuple representing the status of the fork, and the number of blocks mined by an attacker, the honest miners,  and {\em eclipse attack} victim~\cite{Heilman:2015}, respectively.   Gervais et al.\ encoded several factors into the MDP that affect  attacker strategy, including mining power, block depth, connectivity, and the impact of eclipse attacks. The MDP was implemented with a cutoff value of 20 blocks, representing an attack of finite duration. Via a search algorithm over the space defined by the MDP, and in combination with a simulation of a blockchain system that determined for example block propagation times and throughput, they determined the maximum transaction value that would be safe from double spending by an economically rational attacker. This  approach is rich, capturing the optimal strategy for  double-spending (as well as selfish mining~\cite{eyal:2014,sapirshtein:2015}) given  network conditions and blockchain parameters.  Gervais et al.\ were able to reach many fascinating conclusions  about the comparative performance and security of several widely used blockchains.

\para{Double spending.} 
A fundamental attack against Bitcoin is the {\em double-spend} attack~\cite{Nakamoto:2009},
which works as follows. An attacker creates a transaction that moves
funds to a merchant's address. After the transaction appears in the
newest block on the main branch, the attacker takes possession of the purchased
goods. Using his mining power, the attacker then immediately releases
two blocks, with a transaction in the first that moves the funds to a
second attacker-owned address. Now the attacker has the goods and his
coin back. To defend against the attack, a merchant can refuse to
release goods to a Bitcoin-paying customer until $z$ blocks have been
added to the blockchain including the first block containing a
transaction moving coin to the merchant's address.  Nakamoto
calculated the probability of the attack succeeding assuming that the
miner controlled a given fraction of the mining power~\cite{Nakamoto:2009};
for a given fraction, the probability of success decreases exponentially as $z$
increases. 

In general, a merchant may wait $z$ blocks before releasing goods,
which can thwart an attacker.
But choosing the minimum value of $z$ that secures a transaction is an
unresolved issue. The core Bitcoin client shows that a transaction is
unconfirmed until it is 6 blocks deep in the
blockchain\cite{bitcoin:confirmation}, and   advice from others is necessarily vague; e.g., ``for very large transactions, coin
owners might want to wait for a larger number of block
confirmations''~\cite{Bonneau:2015a}.   

\subsection{Related Work}
The standard Bitcoin protocol requires miners to broadcast a block they mined immediately. However, in the case of selfish mining, a miner purposefully withholds his blocks. The motivation is to bifurcate the chain and waste the computational resources of the honest miners should the network decide to build on the attacker's chain. An attacker can not profit economically since the number of blocks that can be created by a miner depends on the fraction of the mining power he has. However, selfish mining discards the honest miners' blocks, by releasing an alternative chain that takes over the current longest chain. If a selfish mining attack is successful, the selfish miners own a higher fraction of the blocks on the main chain because some portion of the blocks created by the honest network go to waste.

Eyal et al.~\cite{eyal:2014} modeled selfish mining using a Markov chain. Then Sapirshtein et al.~\cite{sapirshtein:2015} created a more complex model using a Markov decision process (MDP) for selfish mining and computed the $\epsilon$-optimal policy that increases a selfish miner's revenue. Recently, Gervais et al.~\cite{Gervais:2016} incorporated additional parameters such as network conditions and Bitcoin settings into the MDP to study the affects of such parameters on the attacker's policy. %that affect  attacker strategy, including mining power, block depth, connectivity, and the impact of eclipse attacks.

Sapirshtein et al.~\cite{sapirshtein:2015} first observed that some double-spend attacks can be carried out essentially cost-free in the presence of a concurrent selfish mining~\cite{eyal:2014} attack. 
More recent work extends the scope of double-spends that can benefit from selfish mining to cases where the attacker is capable of \emph{pre-mining} blocks on a secret branch at little or no opportunity cost~\cite{Sompolinsky:2016}. The papers identify the optimal mining strategy for an attacker and quantify the advantage that he can expect to have over the merchant in terms of pre-mined blocks.
This analysis is complementary to ours; it is possible to relatively easily incorporate the pre-mining advantage into our model by simply changing the attacker's block target from $z$ to $z-c$. We note that pre-mining in the context of the eclipse attack may not be feasible since an eclipse cannot generally be carried out for an indefinite period of time. Nevertheless, we intend to update both of our double-spend analyses to account for cost-free pre-mining in future work.

Gervais et al.~\cite{Gervais:2016} is the work most directly related to our objectives.  Rosenfeld~\cite{Rosenfeld:2012} also has the same economic objective. As we discuss in Section~\ref{sec:discussion}, in general, the approach taken by past work, including Gervais et al., Rosenfeld, and the works cited above, models only the \emph{order} of block creation, which is a discrete process; they do not model block mining time, which is a continuous process. As a result, it is difficult to extend those results to model cost in circumstances where the attacker is given a specific deadline in time (as we have done in our eclipse attack analysis) or where an attacker drops out (because the honest miners have already won) but has spent time mining. We develop a richer, continuous-time model that explicitly accounts
for attacker cost as a function of mining duration.  

\section{Problem Statement}
In this project, we study a form of adversarial behavior in cryptocurrencies. Known as selfish mining, this behavior involves the deliberate withholding of transaction information. We study whether an attacker who wants to perform selfish mining could use a reinforcement learning method to search for the optimal strategy. Furthermore, we compare the optimal policy found by RL algorithms to those cited in previous work.

\para{Parametrization of $\beta$.}
Let $X = X_1, \dots, X_{n}$, where $X \sim$ Exp$(\beta)$, where $\beta = 1/\lambda$. The MLE estimator for $\beta$ is
\begin{align}
\hat{\beta} = \frac{\sum_{i=1}^{n} X_i}{n}
\end{align}
The expected value of the estimator is 
\begin{align}
\EX[\hat{\beta} | \beta] &= \frac{1}{n}\EX \Bigg[\sum_{i=1}^{n} X_i \Bigg] \\
&= \frac{1}{n}n\beta \\
&= \beta
\end{align}
This estimator \textit{not} biased. The bias is
\begin{align}
\text{bias}(\hat{\beta}) &= \EX[\hat{\beta} | \beta] - \beta \\
&= \beta - \beta \\
&= 0
\end{align}
The variance of the estimator is
\begin{align}
\text{Var}(\hat{\beta}) &= \text{Var}\Bigg(\frac{\sum_{i=1}^{n} X_i}{n}\Bigg) \\
&= \frac{1}{n^2} \text{Var}\Bigg(\sum_{i=1}^{n} X_i\Bigg) \\
&= \frac{1}{n^2} n\beta^2\\
&= \frac{1}{n}\beta^2
\end{align}
Ideally, in Bitcoin $\beta = 1/10$ mins and in Ethereum $\beta = 1/15$ secs. Note that the variance increases with more data (more inter-arrival times).

\para{Understanding the Relationship Between Hash Rate and $\beta$.}
Given target $T_i$, the expected number of hashes, $h$, needed to meet the target for a block is
\begin{align}
\EX[h] = \frac{2^{256}-1}{T_i}
\end{align}
However, $\EX[h]$ describes the \textit{total} number of expected hashes needed to find a block. We have observations regarding the \textit{time} it takes to generate a block. Let $r$ be the hash rate of the network in minutes (or the number of hashes per time unit), and $X = X_1, \dots, X_{n}$, where $X \sim$ Exp$(\beta)$, where $\beta = 1/\lambda$. Note that $\lambda r$ is the expected number of hashes each time a block is created.  %We do not know the real value of $\beta$ but can use the estimator in eq. 1.
\begin{align}
\EX[h] = r \lambda &= r \frac{1}{\beta}  \\
r &= \EX[h] \beta
\end{align}

\para{Expected Value of Hash Rate.}
\begin{align}
\EX[r|T_i,X_1,...,X_n] &= \EX\bigg[\frac{(2^{256}-1)\hat{\beta}}{T_i}\bigg] \\
&= \frac{(2^{256}-1)}{T_i}\EX[\hat{\beta}] \\
&= \frac{(2^{256}-1)\beta}{T_i}
\end{align}

\para{Variance of Hash Rate.}
\begin{align}
\text{Var}(r|T_i,X_1,...,X_n) &= \text{Var}\bigg(\frac{(2^{256}-1)\hat{\beta}}{T_i}\bigg) \\
&= \frac{(2^{256}-1)^2}{T_i^2} \text{Var}(\hat{\beta}) \\
&= \frac{(2^{256}-1)^2\beta^2}{T_i^2n}
\end{align}

\para{Bias of Hash Rate.}
\begin{align}
\text{bias}(r|T_i,X_1,...,X_n) &= \EX[r|T_i,X_1,...,X_n] - r \\
&= \frac{(2^{256}-1)\beta}{T_i} - \frac{(2^{256}-1)\beta}{T_i} \\
&= 0
\end{align}

The variance for estimating the miner hash rate is huge! You'd require more blocks than those that are in the blockchain to reduce variance! Therefore, let's use RL. 

\para{Example.}
The current Bitcoin difficulty, $D_i$, is $1,590,896,927,258 \approx 2^{40}$. This means the current target, $T_i$, is
\begin{align}
T_i &= \frac{2^{224}}{D_i} = \frac{2^{224}}{2^{40}} \\
&\approx 2^{184}
\end{align}
Then approximately the variance associated with the hash rate is 
\begin{align}
\text{Var}(r|T_i,X_1,...,X_n) &= \frac{(2^{256}-1)^2\beta^2}{T_i^2n} \\
&\approx  \frac{(2^{256})^2\beta^2}{T_i^2n} \\
&\approx  \frac{(2^{256})^2\beta^2}{(2^{184})^2n} \\
&\approx  \frac{2^{512}\beta^2}{2^{368}n} \\
&\approx  2^{144}\frac{\beta^2}{n}
\end{align}
A huge number no matter what $\beta$ or $n$ is!

\section{Preliminary Work}
\subsection{Formulating the Problem as an MDP}
\para{States.} Using Sapirshtein et al.~\cite{sapirshtein:2015}'s model as a basis, we construct the following MDP that is a 6-tuple $\{S, A, P, R, \gamma, d_0\}$, where $S = \{(x, y, z)\}$ such that $x, y, z \in \mathbb{N}$. The state consists of a 3-tuple where $x$ denotes the number of blocks on the attacker's hidden chain, $y$ denotes the number of blocks created by the honest miners on the main chain, and $z$ denotes the number of blocks that the attacker released on the main chain. Note that this representation assumes that all blocks build on the same parent block. 

\para{Actions.} $A = \{\texttt{adopt}, \texttt{mine}, \texttt{override}, \texttt{match}\}$. \texttt{adopt} refers to the adoption of the main chain, thereby discarding all blocks created by the attacker. The action \texttt{mine} denotes that the attacker continues to mine, waiting to see who the next block will be discovered by. \texttt{override} refers to an attacker's releasing one more block than the honest miners' blocks on the main chain. This action can be viewed as honest or selfish depending on the current state. If the honest miners have no blocks on the main chain, an addition of a block to the main chain means that the attacker is honest. However, if the honest miners already have blocks on the main chain and the attacker releases an alternative chain that is 1 block longer than that created by the honest miners, then the attacker overwrites the main chain, wasting the victim's computational resources. The \texttt{match} action means that the attacker releases as many blocks as there are on the main chain, causing a bifurcation.

\para{Initial state distribution.} $d_0 = \{(0, 0, 0)\}$, where $P(S_0 = (0, 0, 0)) = 1$. In other words, the start state assumes that no blocks have been mined yet. When the attacker chooses the action  \texttt{adopt}, the agent goes back to the start state because a new parent block is chosen to build on top of.

\para{Transition Function.} We consider 3 of parameters of interest included in Gervais et al.~\cite{Gervais:2016}'s model. At each time step, a new block is created by the network: with probability $q$, where $q$ is the mining power of the attacker, the attacker is the winner of a new block. The honest network discovers a block with probability $1-q$. Not all actions are available in every state. The attacker can always choose the \texttt{mine} action. The \texttt{adopt} action is only available when there are blocks on the main chain created by the honest network. Additionally, \texttt{override} and \texttt{match} are only available when the attackers have enough blocks. At cutoff, $c=30$, we force the attacker to choose the \texttt{adopt} action in order to have episodic trials. If the number of blocks created by the honest miners exceeds those of the attacker by $c$, we force the attacker to end the episode. Our third parameter, $a$, represents network connectivity. If there is a fork of same length on the main chain, fraction $a$ of the honest miners build on the attacker's alternative chain. We set $a=1$ to give advantage to the attacker, and to see if RL methods can learn to take advantage of the \texttt{match} action. If the attacker matches the main chain with a fork of the same length, all honest miners build on the attacker's chain. 

\section{Proposed Work}

